#!/usr/bin/python3

import os
import json
import math
import subprocess
from itertools import repeat
from datetime import datetime
from typing import Optional, List, Dict, Any
from lemonbar_manager import Module, Manager

FOREGROUND_COLOR = '#ffB2B2B2'
BACKGROUND_COLOR = '#c00A0E14'
# BACKGROUND_COLOR = '#ff111111'
UNDERLINE_COLOR = '#D8AD4C'
UNDERLINE_WIDTH = 2
FONTS = ['Cascadia Mono']

BAR_SIZE = 192
CLOCK_MODULE_SIZE = len(datetime.now().strftime(' %a %d %h, %I:%M %p '))
WORKSPACES_MODULE_SIZE = 45
# WINDOWS_MODULE_SIZE = BAR_SIZE - WORKSPACES_MODULE_SIZE - CLOCK_MODULE_SIZE
WINDOWS_MODULE_SIZE = 142

print('BAR_SIZE:', BAR_SIZE)
print('CLOCK_MODULE_SIZE:', CLOCK_MODULE_SIZE)
print('WORKSPACES_MODULE_SIZE:', WORKSPACES_MODULE_SIZE)
print('WINDOWS_MODULE_SIZE:', WINDOWS_MODULE_SIZE)

UNICODE_ELLIPSIS = '\u2026'

class Const(Module):
    def __init__(self, value):
        super().__init__()
        self._value = value

    def output(self):
        return self._value


class Clock(Module):
    def __init__(self):
        super().__init__()
        self.wait_time = 60  # How often to update this module (TODO: sync update time with minutes)

    def output(self):
        return datetime.now().strftime(' %a %d %h, %I:%M %p ')

class Workspaces(Module):
    def __init__(self):
        super().__init__()
        # TODO - use a more specific subscription for better performance
        self._subscription_process = subprocess.Popen(
            ['dskmgr', 'subscribe'], stdout=subprocess.PIPE, encoding='UTF-8')
        self.readables = [self._subscription_process.stdout]
        self._viewport = range(0, 6)
    
    def _single_output(self, index: int, size: int, y: int, selected: Optional[bool]) -> str:
        if selected:
            if size == 1:
                return f'%{{R}}    {index+1}    %{{R}}'
            return f'%{{R}} {index+1} ({y+1}/{size}) %{{R}}'
        return f'  {index+1}{subscript(size) if size > 1 else " "} '

    def _parse_state(self, raw: str) -> Dict[str, Any]:
        return json.loads(raw)

    def output(self) -> str:
        state = self._parse_state(self.readables[0].readline())
        print(state)
        outputs = []
        selected = state.get('focused')
        for i, d in enumerate(state.get('groups')):
            outputs += [self._single_output(i, d['size'], d['y'], i == selected)]
        
        if selected < self._viewport.start:
            self._viewport = range(selected, selected + len(self._viewport))
        elif selected >= self._viewport.stop:
            last = min(selected, len(outputs) - 2)
            self._viewport = range(last + 1 - len(self._viewport), last + 1)

        prefix  = f'{UNICODE_ELLIPSIS} ' if self._viewport.start != 0 else '  '
        if self._viewport.stop < len(outputs):
            postfix = outputs[-1] if self._viewport.stop == len(outputs) - 1 else f' {UNICODE_ELLIPSIS}{outputs[-1]}'
        else:
            postfix = ''

        return ' ' + prefix + ''.join(outputs[self._viewport.start:self._viewport.stop]) + postfix + ' '


class Windows(Module):
    def __init__(self, size):
        super().__init__()
        self._size = size
        self._subscription_process = subprocess.Popen(
            ['bspc', 'subscribe', 'node_focus', 'node_remove', 'desktop_focus'], stdout=subprocess.PIPE, encoding='UTF-8')
        self.readables = [self._subscription_process.stdout]

    def _center_text(self, text: str, size: int):
        padding_amount = size - len(text)
        left_padding, right_padding = math.ceil(padding_amount / 2), math.floor(padding_amount / 2)
        return ' ' * left_padding + text + ' ' * right_padding

    def _render_tab(self, tab_size: int, name: str, selected: bool = False) -> str:
        if len(name) <= tab_size - 2:
            text = self._center_text(name, tab_size - 2)
        else:
            text = name[:tab_size-3] + UNICODE_ELLIPSIS
        return f'%{{R}} {text} %{{R}}' if selected else f' {text} '

    # def _get_windows
    def _get_window_name(self, identifier: str) -> str:
        return subprocess.check_output(['xprop', '-id', identifier, '-notype', 'WM_NAME']).decode().strip()[11:-1]

    def _get_windows(self) -> List[str]:
        try:
            # TODO - this throws an exception if there are no windows
            return subprocess.check_output(['bspc', 'query', '-N', '-n', '.window', '-d', 'focused']).decode().strip().split()
        except:
            return []

    def _get_focused_window(self) -> str:
        return subprocess.check_output(['bspc', 'query', '-N', '-n', '.focused']).decode().strip()

    def output(self) -> str:
        self.readables[0].readline()
        windows = self._get_windows()
        if len(windows) == 0:
            return ''
        focused_window = self._get_focused_window()
        tab_size = self._size // len(windows)
        return ''.join(self._render_tab(tab_size, self._get_window_name(w), w == focused_window and len(windows) > 1) for w in windows)

def itoa_with_values(value: int, values: str, base=10) -> str:
    assert len(values) == base
    result = ''
    while True:
        result = values[value % base] + result
        value //= base
        if value == 0:
            return result

def superscript(value: int) -> str:
    return itoa_with_values(value, '⁰¹²³⁴⁵⁶⁷⁸⁹')

def subscript(value: int) -> str:
    return itoa_with_values(value, '₀₁₂₃₄₅₆₇₈₉')

modules = (
    # Const(f'%{{l}}'),
    # Const(' ' * WORKSPACES_MODULE_SIZE),
    # Const(f'%{{B#3FBF3F}}%{{F{BACKGROUND_COLOR}}}'),
    # Windows(WINDOWS_MODULE_SIZE),

    # Const(f'%{{r}}'),
    # # Const(f'%{{B#3FBF3F}}%{{F{BACKGROUND_COLOR}}}'),
    # Windows(WINDOWS_MODULE_SIZE),
    # Const(' ' * CLOCK_MODULE_SIZE + ' '),

    Const(f'%{{B{BACKGROUND_COLOR}}}%{{F{FOREGROUND_COLOR}}}'),
    # Const(f'%{{B#3FBF3F}}%{{F{BACKGROUND_COLOR}}}'),
    Const('%{l}'),
    Workspaces(),
    Const('%{r}'),
    Const(f'%{{B{FOREGROUND_COLOR}}}%{{F{BACKGROUND_COLOR}}}'),
    Clock(),
    Const('%{B-}%{F-}')
    # Const('%{Bff000000}%{Fff000000}'),
)

command = (
    'lemonbar',
    # '-b', # put bar at bottom of screen
    # '-a', '40', # number of clickable areas
    '-g', '1920x25', # window geometry (in this case set height)
    '-B', BACKGROUND_COLOR,
    '-F', FOREGROUND_COLOR,
    '-U', UNDERLINE_COLOR, # underline color
    '-u', str(UNDERLINE_WIDTH),
    *[i for j in zip(repeat('-f'), FONTS) for i in j]
)

with Manager(command, modules) as mgr:
    mgr.loop()